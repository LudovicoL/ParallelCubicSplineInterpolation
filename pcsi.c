#include "MyLibrary.h"


int main (int argc, char *argv[]) {
	
	/* Variables definition */

	int n;								// number of input elements
	int p;								// number of processors
	int rank;							// process rank
	double total_time;					// time to execution for each process (includes write to file)
	double time_without_writing = 0;	// time to execution for each process (excludes write to file)

	FILE *source = NULL;
	char *filename_input = "./input.txt";		// name of input file (default: "./input.txt")
	char *filename_output = "./output.txt";		// name of output file (default: "./output.txt")
	
	double step = 0.1;				// step size (default: 0.1)

	double *io_xi = NULL;			// input/output xi-coordinates array
	double *io_yi = NULL;			// input/output yi-coordinates array

	double *xi = NULL;				// array of partial xi after Scatterv
	double *yi = NULL;				// array of partial yi after Scatterv

	int effective_partial_size;		// number of effective elements into arrays xi and yi
	int total_partial_size;			// number of total elements into arrays xi and yi
	
	int *count = NULL;				// array describing how many elements to send to each process
	int *displ = NULL;				// array describing the displacements where each segment begins

	double *m = NULL;				// H Ã— m = r - unknowns array

	int sigma_i = 0;				// value of interval generated by Cubic Spline Interpolation method
	int sigma;						// value of total number generated by Cubic Spline Interpolation method
	int *array_sigma_i = NULL;		// array of intervals generated by every process during Cubic Spline Interpolation method
	double *x = NULL;				// array of x-coordinate of Cubic Spline Interpolation
	double *fx = NULL;				// array of y-coordinate of Cubic Spline Interpolation

	char write_output = 'n';		// save results in a file
	int help = 0;					// show commands list


	/* Command-line options */
	for (int i=0; i<argc; i++) {
		if (strcmp(argv[i], "-fi") == 0) {
			filename_input = argv[i+1];
		}
		if (strcmp(argv[i], "-s") == 0) {
			step = atof(argv[i+1]);
		}
		if (strcmp(argv[i], "-fo") == 0) {
			filename_output = argv[i+1];
		}
		if (strcmp(argv[i], "-o") == 0) {
			write_output = *argv[i+1];
		}
		if (strcmp(argv[i], "-help") == 0) {
			help = 1;
		}
	}

	/* Start MPI */
	MPI_Init(&argc, &argv);
	MPI_Barrier(MPI_COMM_WORLD);
	total_time = - MPI_Wtime();				// Start time counting
	
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);	// Get the current rank of process
	MPI_Comm_size(MPI_COMM_WORLD, &p);		// Get the number of processes


	if(help) {
		if(rank == 0) {
			printf("\nCOMMANDS LIST:\n-np: set the number of processes.\n-fi: set an input filename.\n-fo: set an output filename.\n-s: set a step-size.\n-o: save results in a file (n/y).\n\n");
		}
		MPI_Finalize();
		return 0;
	}

	/* Read the input data */
	if(rank == 0) {
		if(step <= 0) {
			fprintf(stderr, "ERROR: Step-size can't be negative or equal to zero!\n");
			return -1;
		}

		// Open the input file
		if((source = fopen(filename_input, "rt")) == NULL) {
			fprintf(stderr, "Error with input fopen!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
			return -1;
		}

		if(fscanf(source, "%d", &n) != 1) {		// Read the number of elements n
			fprintf(stderr, "ERROR: Expected one number as input for n value!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
			return -1;
		}

		if(p > n) {
			fprintf(stderr, "ERROR: Number of processes can't be greater than n!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
			return -1;
		}

		if(n < 2) {
			fprintf(stderr, "ERROR: n can't be less than 2!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
			return -1;
		}

		io_xi = (double*) malloc(n * sizeof(double));
		if(io_xi == NULL) { checkMalloc(getName(io_xi)); return -1; }

		io_yi = (double*) malloc(n * sizeof(double));
		if(io_yi == NULL) { checkMalloc(getName(io_yi)); return -1; }
		
		for(int i = 0; i < n; i++) {			// Read xi-coordinates
			if(fscanf(source, "%lf", &io_xi[i]) != 1) {
				fprintf(stderr, "ERROR: Expected one number as input for io_xi array!\n");
				MPI_Abort(MPI_COMM_WORLD, -1);
				return -1;
			}
		}
		for(int i = 0; i < n; i++) {			// Read yi-coordinates
			if(fscanf(source, "%lf", &io_yi[i]) != 1) {
				fprintf(stderr, "ERROR: Expected one number as input for io_yi array!\n");
				MPI_Abort(MPI_COMM_WORLD, -1);
				return -1;
			}
		}
		fclose(source);
		source = NULL;

		if(step >= 1){							// Calculate total number generated by Cubic Spline Interpolation method
			sigma = ((io_xi[n-1]-io_xi[0]) * step) + 1;
		} else {
			sigma = ((io_xi[n-1]-io_xi[0]) / step) + 1;
		}

		if(p == 1) {							// If there is just a process that execute the program
			sigma_i = sigma;
		}
	}

	
	/* Send n, xi and yi */
	MPI_Bcast(&n, 1, MPI_INT, 0, MPI_COMM_WORLD);		// Send n to each process

	create_counts_and_displs_with_replications (rank, p, n, 1, &count, &displ);
	
	xi = (double*) malloc(count[rank] * sizeof(double));
	if(xi == NULL) { checkMalloc(getName(xi)); return -1; }
	
	yi = (double*) malloc(count[rank] * sizeof(double));
	if(yi == NULL) { checkMalloc(getName(yi)); return -1; }
	
	

	// Send xi and yi to each process according to arrays count and displ
	MPI_Scatterv(io_xi, count, displ, MPI_DOUBLE, xi, count[rank], MPI_DOUBLE, 0, MPI_COMM_WORLD);
	MPI_Scatterv(io_yi, count, displ, MPI_DOUBLE, yi, count[rank], MPI_DOUBLE, 0, MPI_COMM_WORLD);

	if(rank == 0) {
		free(io_xi); io_xi = NULL;
		free(io_yi); io_yi = NULL;
	}
	

	/* Calculate the indexes for each process */
	total_partial_size = count[rank];		// dimension of total elements into array xi and yi
	
	if(rank == 0 || rank == p - 1) {		// dimension of effective elements into array xi and yi
		effective_partial_size = total_partial_size - 1;
	} else {
		effective_partial_size = total_partial_size - 2;
	}

	/* Calculate m */
	parallelThomasAlgorithm(rank, p, n, total_partial_size, effective_partial_size, xi, yi, &m);

	MPI_Barrier (MPI_COMM_WORLD);

	/* Parallel Cubic Spline Interpolation method */
	parallelCubicSplineInterpolation (rank, p, step, effective_partial_size, xi, yi, m, &x, &fx, &sigma_i);

	MPI_Barrier (MPI_COMM_WORLD);

	free(xi); xi = NULL;
	free(yi); yi = NULL;
	free(m); m = NULL;



	/* Obtain intervals, xi and yi calculated from Cubic Spline Interpolation method */
	array_sigma_i = (int*) calloc(p, sizeof(int));

	MPI_Gather(&sigma_i, 1, MPI_INT, array_sigma_i, 1, MPI_INT, 0, MPI_COMM_WORLD);		// Collect intervals into an array

	if(rank == 0) {
		count[0] = array_sigma_i[0];
		displ[0] = 0;
		for(int i = 1; i < p; i++) {
			count[i] = array_sigma_i[i];
			displ[i] = displ[i-1] + count[i-1];
		}

		io_xi = (double*) malloc(sigma * sizeof(double));
		if(io_xi == NULL) { checkMalloc(getName(io_xi)); return -1; }
		
		io_yi = (double*) malloc(sigma * sizeof(double));
		if(io_yi == NULL) { checkMalloc(getName(io_yi)); return -1; }
		

	}

	MPI_Gatherv(x, sigma_i, MPI_DOUBLE, io_xi, count, displ, MPI_DOUBLE, 0, MPI_COMM_WORLD);
	MPI_Gatherv(fx, sigma_i, MPI_DOUBLE, io_yi, count, displ, MPI_DOUBLE, 0, MPI_COMM_WORLD);

	MPI_Barrier (MPI_COMM_WORLD);
	time_without_writing = total_time + MPI_Wtime();

	/* Write the ouput data */
	if(rank == 0) {
		if(write_output == 'y') {
			// Open the output file
			if((source = fopen(filename_output, "wt")) == NULL) {
				fprintf(stderr, "Error with output fopen!\n");
				MPI_Abort(MPI_COMM_WORLD, -1);
				return -1;
			}
			fprintf(source,"%d\n", sigma);								// write value of n
			for(int i = 0; i < sigma; i++) {
				fprintf(source,"%lf\t%lf\n", io_xi[i], io_yi[i]);		// write io_xi and io_yi
			}
			fclose(source);
		}

		free(io_xi); io_xi = NULL;
		free(io_yi); io_yi = NULL;
		
	}


	
	free(array_sigma_i); array_sigma_i = NULL;
	free(count); count = NULL;
	free(displ); displ = NULL;

	MPI_Barrier (MPI_COMM_WORLD);

	if(write_output == 'y') {
		total_time += MPI_Wtime();				// Stop the time count
		// Evaluate time spent to execute the program.
		double max_total_time = 0;
		double min_total_time = 0;
		MPI_Reduce(&total_time, &max_total_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);	// Obtained the maximum time spent
		MPI_Reduce(&total_time, &min_total_time, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);	// Obtained the minimum time spent
		double max_time_without_writing = 0;
		double min_time_without_writing = 0;
		MPI_Reduce(&time_without_writing, &max_time_without_writing, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);	// Obtained the maximum time spent without writing
		MPI_Reduce(&time_without_writing, &min_time_without_writing, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);	// Obtained the minimum time spent without writing
		if (rank == 0) {
			printf("\nWALL CLOCK TIME:\n");
			printf("\tTotal time\tMaximum: %f\tMinimum: %f\n", max_total_time, min_total_time);
			printf("\tComputation\tMaximum: %f\tMinimum: %f\n\n", max_time_without_writing, min_time_without_writing);
		}
	} else {
		double max_time_without_writing = 0;
		double min_time_without_writing = 0;
		MPI_Reduce(&time_without_writing, &max_time_without_writing, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);	// Obtained the maximum time spent without writing
		MPI_Reduce(&time_without_writing, &min_time_without_writing, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);	// Obtained the minimum time spent without writing
		if (rank == 0) {
			printf("\nWALL CLOCK TIME:\tMaximum: %f\tMinimum: %f\n\n", max_time_without_writing, min_time_without_writing);
		}
	}

	
	MPI_Finalize();
	return 0;
}
