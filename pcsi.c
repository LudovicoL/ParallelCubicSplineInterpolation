#include "MyLibrary.h"


int main (int argc, char *argv[]) {
	
	/* Variables definition */

	int n;							// number of input elements
	int p;							// number of processors
	int rank;						// process rank
	double time;					// time to execution for each process
	
	FILE *source = NULL;
	char *filename_input = "./input.txt";		// name of input file (default: "./input.txt")
	char *filename_output = "./output.txt";		// name of output file (default: "./output.txt")
	
	double step = 0.1;				// step size (default: 0.1)

	double *io_xi = NULL;			// input/output xi-coordinates array
	double *io_yi = NULL;			// input/output yi-coordinates array

	double *xi = NULL;				// array of partial xi after Scatterv
	double *yi = NULL;				// array of partial yi after Scatterv

	int effective_partial_size;		// number of effective elements into arrays xi and yi
	int total_partial_size;			// number of total elements into arrays xi and yi
	
	int *count = NULL;    			// array describing how many elements to send to each process
	int *displ = NULL;       		// array describing the displacements where each segment begins

	double *m = NULL;				// H Ã— m = r - unknowns array

	int interval = 0;				// value of interval generated by Cubic Spline Interpolation method
	int total_n;					// value of total number generated by Cubic Spline Interpolation method
	int *array_intervals = NULL;	// array of intervals generated by every process during Cubic Spline Interpolation method
	double *x = NULL;				// array of x-coordinate of Cubic Spline Interpolation
	double *fx = NULL;				// array of y-coordinate of Cubic Spline Interpolation



	/* Command-line options */
	for (int i=0; i<argc; i++) {
		if (strcmp(argv[i], "-fi") == 0) {
			filename_input = argv[i+1];
		}
		if (strcmp(argv[i], "-s") == 0) {
			step = atof(argv[i+1]);
		}
		if (strcmp(argv[i], "-fo") == 0) {
			filename_output = argv[i+1];
		}
	}



	/* Start MPI */
	MPI_Init(&argc, &argv);
	MPI_Barrier(MPI_COMM_WORLD);
	time = - MPI_Wtime();					// Start time counting
	
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);	// Get the current rank of process
	MPI_Comm_size(MPI_COMM_WORLD, &p);		// Get the number of processes



	/* Read the input data */
	if(rank == 0) {
		// Open the input file
		if((source = fopen(filename_input, "rt")) == NULL) {
			printf("Error with input fopen!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
			return -1;
		}

		if(fscanf(source, "%d", &n) != 1) {		// Read the number of elements n
			fprintf(stderr, "Expected one number as input for n value!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
			return -1;
		}

		io_xi = (double*) malloc(n * sizeof(double));
		if(io_xi == NULL) { fprintf(stderr, "Malloc error (io_xi variable)!"); MPI_Abort(MPI_COMM_WORLD, -1); return -1; }

		io_yi = (double*) malloc(n * sizeof(double));
		if(io_yi == NULL) { fprintf(stderr, "Malloc error (io_yi variable)!"); MPI_Abort(MPI_COMM_WORLD, -1); return -1; }
		
		for(int i = 0; i < n; i++) {			// Read xi-coordinates
			if(fscanf(source, "%lf", &io_xi[i]) != 1) {
				fprintf(stderr, "Expected one number as input for io_xi array!\n");
				MPI_Abort(MPI_COMM_WORLD, -1);
				return -1;
			}
		}
		for(int i = 0; i < n; i++) {			// Read yi-coordinates
			if(fscanf(source, "%lf", &io_yi[i]) != 1) {
				fprintf(stderr, "Expected one number as input for io_yi array!\n");
				MPI_Abort(MPI_COMM_WORLD, -1);
				return -1;
			}
		}
		fclose(source);
		source = NULL;

		if(step >= 1){							// Calculate total number generated by Cubic Spline Interpolation method
			total_n = ((io_xi[n-1]-io_xi[0]) * step) + 1;
		} else {
			total_n = ((io_xi[n-1]-io_xi[0]) / step) + 1;
		}
	}


	/* Send n, xi and yi */
	MPI_Bcast(&n, 1, MPI_INT, 0, MPI_COMM_WORLD);		// Send n to each process

	create_counts_and_displs_with_replications (rank, p, n, 1, &count, &displ);
	
	xi = (double*) malloc(count[rank] * sizeof(double));
	if(xi == NULL) { fprintf(stderr, "Malloc error (xi variable)!"); MPI_Abort(MPI_COMM_WORLD, -1); return -1; }
	
	yi = (double*) malloc(count[rank] * sizeof(double));
	if(yi == NULL) { fprintf(stderr, "Malloc error (yi variable)!"); MPI_Abort(MPI_COMM_WORLD, -1); return -1; }
	
	

	// Send xi and yi to each process according to arrays count and displ
	MPI_Scatterv(io_xi, count, displ, MPI_DOUBLE, xi, count[rank], MPI_DOUBLE, 0, MPI_COMM_WORLD);
	MPI_Scatterv(io_yi, count, displ, MPI_DOUBLE, yi, count[rank], MPI_DOUBLE, 0, MPI_COMM_WORLD);

	if(rank == 0) {
		free(io_xi); io_xi = NULL;
		free(io_yi); io_yi = NULL;
	}
	

	/* Calculate the indexes for each process */
	total_partial_size = count[rank];		// dimension of total elements into array xi and yi
	
	if(rank == 0 || rank == p - 1) {		// dimension of effective elements into array xi and yi
		effective_partial_size = total_partial_size - 1;
	} else {
		effective_partial_size = total_partial_size - 2;
	}

	/* Calculate m */
	parallelThomasAlgorithm(rank, p, n, total_partial_size, effective_partial_size, xi, yi, &m);

	MPI_Barrier (MPI_COMM_WORLD);

	/* Parallel Cubic Spline Interpolation method */
	parallelCubicSplineInterpolation (rank, p, step, effective_partial_size, xi, yi, m, &x, &fx, &interval);

	MPI_Barrier (MPI_COMM_WORLD);

	free(xi); xi = NULL;
	free(yi); yi = NULL;
	free(m); m = NULL;



	/* Obtain intervals, xi and yi calculated from Cubic Spline Interpolation method */
	array_intervals = (int*) calloc(p, sizeof(int));

	MPI_Gather(&interval, 1, MPI_INT, array_intervals, 1, MPI_INT, 0, MPI_COMM_WORLD);		// Collect intervals into an array

	if(rank == 0) {
		count[0] = array_intervals[0];
		displ[0] = 0;
		for(int i = 1; i < p; i++) {
			count[i] = array_intervals[i];
			displ[i] = displ[i-1] + count[i-1];
		}

		io_xi = (double*) malloc(total_n * sizeof(double));
		if(io_xi == NULL) { fprintf(stderr, "Malloc error (io_xi variable)!"); MPI_Abort(MPI_COMM_WORLD, -1); return -1; }
		
		io_yi = (double*) malloc(total_n * sizeof(double));
		if(io_yi == NULL) { fprintf(stderr, "Malloc error (io_yi variable)!"); MPI_Abort(MPI_COMM_WORLD, -1); return -1; }
		

	}

	MPI_Gatherv(x, interval, MPI_DOUBLE, io_xi, count, displ, MPI_DOUBLE, 0, MPI_COMM_WORLD);
	MPI_Gatherv(fx, interval, MPI_DOUBLE, io_yi, count, displ, MPI_DOUBLE, 0, MPI_COMM_WORLD);



	/* Write the ouput data */
	if(rank == 0) {
		// Open the output file
		if((source = fopen(filename_output, "wt")) == NULL) {
			printf("Error with output fopen!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
			return -1;
		}
		fprintf(source,"%d\n", total_n);							// write value of n
		for(int i = 0; i < total_n; i++) {
			fprintf(source,"%lf\t%lf\n", io_xi[i], io_yi[i]);		// write io_xi and io_yi
		}
		fclose(source);

		free(io_xi); io_xi = NULL;
		free(io_yi); io_yi = NULL;
		
	}


	
	free(array_intervals); array_intervals = NULL;
	free(count); count = NULL;
	free(displ); displ = NULL;



	MPI_Barrier (MPI_COMM_WORLD);
	time += MPI_Wtime();				// Stop the time count



	// Evaluate max time spent to execute the program.
	double max_time = 0;
	double min_time = 0;
	MPI_Reduce(&time, &max_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);	// Obtained the maximum time spent
	MPI_Reduce(&time, &min_time, 1, MPI_DOUBLE, MPI_MIN, 0, MPI_COMM_WORLD);	// Obtained the minimum time spent
	if (rank == 0) {
		printf("Maximum wall clock time: %f\nMinimum wall clock time: %f\n", max_time, min_time);
	}



	MPI_Finalize();
	return 0;
}
